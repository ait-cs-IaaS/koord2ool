<template>
  <b-card no-body>
    <b-tabs card>
      <b-tab title="Charts" active>
        <b-container fluid>
          <b-row>
            <b-col
              cols="12"
              md="6"
              lg="4"
              class="avoid-page-break"
              v-for="question of questionKeysOnly"
              :key="question"
            >
              <!-- actual chart -->
              <b-card
                :title="question"
                :sub-title="questions[question].question"
              >
                <pie-chart :counters="countResponsesFor(question)" />

                <line-chart :data="createTimelineFor(question)" />
              </b-card>
            </b-col>
          </b-row>
        </b-container>
      </b-tab>

      <b-tab title="Tabular">
        <tabular
          :show-keys="questionKeys"
          :responses="responses"
          sort-key="token"
        />
      </b-tab>
    </b-tabs>
  </b-card>
</template>

<script lang="ts">
import { Vue, Prop, Component } from "vue-property-decorator";
import LineChart from "@/components/surveys/LineChart.vue";
import PieChart from "@/components/surveys/PieChart.vue";
import Tabular from "@/components/surveys/Tabular.vue";
import ResponseModel, { strip } from "@/store/response.model";
import QuestionModel from "@/store/question.model";
import SurveyModel from "@/store/survey.model";
import { ChartData, ChartDataset } from "chart.js";

@Component({
  components: {
    LineChart,
    PieChart,
    Tabular,
  },
})
export default class Survey extends Vue {
  get questionKeys(): string[] {
    return Array.from(
      new Set<string>(
        this.responses.map((response) => Object.keys(strip(response))).flat()
      )
    ).sort();
  }

  get questionKeysOnly(): string[] {
    return this.questionKeys.filter((key) => key !== "TIME" && key !== "token");
  }

  @Prop({ type: Object, default: () => [] })
  questions!: Record<string, QuestionModel>;

  @Prop({ type: Array, default: () => [] })
  responses!: ResponseModel[];

  @Prop({ type: Object, required: true })
  survey!: SurveyModel;

  private countResponsesFor(questionKey: string) {
    const map = new Map<string, number>();
    this.responses.forEach((response) => {
      const value = response[questionKey] || "N/A";
      map.set(value, (map.get(value) || 0) + 1);
    });
    const asAry: { name: string; value: number }[] = [];
    map.forEach((value, key) => asAry.push({ name: key, value }));

    this.createTimelineFor(questionKey);

    return asAry;
  }

  private createTimelineFor(questionKey: string): ChartData<"line"> {
    const labels: Date[] = [];
    const timeline = new Map<string, { x: number; y: number }[]>();
    const lastChoice = new Map<string, string>();
    this.responses
      .filter(
        (r) => typeof r[questionKey] === "string" && r[questionKey] !== ""
      )
      .map((r) => ({
        token: r.token,
        time: new Date(r.TIME),
        value: String(r[questionKey]),
      }))
      .sort((a, b) => a.time.valueOf() - b.time.valueOf())
      .forEach(({ token, time, value }, index) => {
        labels.push(time);
        const timelineForAnswer = timeline.get(value) || [];
        const newRecord = {
          x: index,
          y: timelineForAnswer.length
            ? timelineForAnswer[timelineForAnswer.length - 1].y + 1
            : 1,
        };
        timelineForAnswer.push(newRecord);
        timeline.set(value, timelineForAnswer);

        const oldAnswer = lastChoice.get(token);
        if (typeof oldAnswer !== "undefined") {
          const oldTimelineForAnswer = timeline.get(oldAnswer) || [];
          const newRecord = {
            x: index,
            y: oldTimelineForAnswer[oldTimelineForAnswer.length - 1].y - 1,
          };
          oldTimelineForAnswer.push(newRecord);
          timeline.set(oldAnswer, oldTimelineForAnswer);
        }
        lastChoice.set(token, value);
      });

    const datasets: ChartDataset<"line">[] = [];
    for (const [key, answerTimeline] of timeline.entries()) {
      const dataset = {
        data: answerTimeline,
        label: key,
        fill: true,
      };
      datasets.push(dataset);
    }
    return { labels, datasets };
  }
}
</script>
